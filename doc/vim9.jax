*vim9.txt*	For Vim バージョン 8.2.  Last change: 2021 Jun 12

		  VIMリファレンスマニュアル    by Bram Moolenaar



THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE

Vim9 script のコマンドと文法					*Vim9* *vim9*

ほとんどの文法については |eval.txt| で解説されています。このファイルには Vim9
script の新しい文法と機能について書かれています。

THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE


1.  Vim9 script とは			|Vim9-script|
2.  変更点				|vim9-differences|
3.  新しいスタイルの関数		|fast-functions|
4.  型					|vim9-types|
5.  名前空間、インポートとエクスポート	|vim9script|
6.  将来的な変更: クラス		|vim9-classes|

9.  言語設計の背景			|vim9-rationale|

==============================================================================

1. Vim9 script とは					*Vim9-script*

THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE


Vim script は、互換性の維持に気を配りながら成長してきました。そのため、古い悪
しき仕様を変更できないことが多いほか、Vi との互換性に制約を受けて、より良い解
決策を採用できなくなっています。処理は遅く、実行するたびに各行のパースが行われ
ています。

Vim9 script の主な目的は劇的な性能の向上です。これは、コマンドをより効率よく実
行できる命令にコンパイルすることで実現しています。これにより、10倍から100倍の
実行速度の向上が期待できます。

第2の目的は、Vim script 特有の文法を回避し、より一般的に使われる JavaScript や
TypeScript、Java のようなプログラミング言語に近づけることです。

パフォーマンスの向上は、100% の下位互換性を捨てることによってのみ達成しうるも
のです。たとえば、関数の引数を辞書 "a:" から利用できるようにするためには、かな
りのオーバーヘッドが必要になります。そのため、Vim9 script では、この辞書が利用
できなくなりました。その他の違いは、エラーの処理方法など、より微細なものです。

Vim9 script は以下の場所で使用することができます:
- コマンド `:def` で定義された関数の中
- コマンド `vim9script` で始まるスクリプトファイルの中
- 上記のコンテキストで定義された自動コマンド
- コマンド修飾子 `vim9cmd` が先頭に付いたコマンド

Vim9 スクリプトファイルの中でコマンド `:function` で関数を定義すると、その中で
は旧来の Vim script の記法が、最新の |scriptversion| とともに有効になります。
しかし、これは混乱を招く可能性があるため、推奨できません。

Vim9 script と旧来の Vim script は同時に利用できます。古いスクリプトを書き換え
なくとも、以前と同様に実行することが可能です。高速化が必要なコードには、`:def`
で定義する関数を使ったほうが良いかもしれません。

:vim9[cmd] {cmd}				*:vim9* *:vim9cmd*
		Vim9 script の構文とセマンティクスを使用して {cmd} を実行しま
		す。コマンドを入力する時と、旧来のスクリプトや関数内で使用する
		時に便利です。

:leg[acy] {cmd}					*:leg* *:legacy*
		旧来のスクリプトの構文とセマンティクスを使用して {cmd} を実行
		します。これが役に立つのは Vim9 script や :def 関数内だけです。
		Note {cmd} ではローカル変数は使えません。旧来の式の構文でパー
		スされるからです。

==============================================================================

2. 旧来の Vim script からの変更点			*vim9-differences*

THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE

概要 ~

Vim9 script と `:def` で定義する関数を使用する際に最もよく遭遇する変更点の概要
は以下のとおりです:
- コメントは " ではなく、# で始めます: >
	echo "hello"   # コメント
- 行継続文字 (\) はほとんどの場合、必要ありません: >
	echo "hello "
	     .. yourName
	     .. ", how are you?"
- 多くの場所にスペースが必要になります。
- 値の代入には `:let` を使用せず、変数の宣言には `:var` を使用します: >
	var count = 0
	count += 3
- `:final` と `:const` を使用して、定数を宣言できます: >
	final matches = []		  # matches を追加
	const names = ['Betty', 'Peter']  # 変更できない
- `:final` は `:finally` の略語として使用することはできません。
- 変数と関数のスコープは、明示しない限りスクリプトローカルです。
- 関数を引数の型、戻り値の型とともに宣言します: >
	def CallMe(count: number, message: string): bool
- 関数は `:call` なしで呼び出します: >
	writefile(['done'], 'file.txt')
- `:xit`、`:t`、`:k`、`:append`、`:change`、`:insert`、`:open`、フラグだけの
  `:s` や `:d`、および波括弧変数は使用できません。
- コマンドの前に範囲指定を置くときは、コロン (:) を前置しなくてはなりません: >
	:%s/this/that
- 特に指定しない限り、最新の |scriptversion| が使われます。

# から始まるコメント ~

旧来の Vim script のコメントは、ダブルクォーテーションで始めます。Vim9 script
のコメントは # で始めます。 >
	# 宣言
	var count = 0  # 出現回数

これは、ダブルクォーテーションは文字列の開始を表す文字でもあるからです。多くの
場所、特に改行を含む式の途中では、文字列とコメントの両方が現れるため、どちらを
意味しているのかわかりにくくなってしまいます。この混乱を避けるために、Vim9
script では、# のみをコメントとして認識します。このコメント形式はシェルスクリ
プトやPythonのコードと同じです。

Vi において # は行番号付きでテキストを表示します。Vim9 script では、代わりに
`:number` を使用します。 >
	101 number

可読性を向上するために、コマンドと #、コメント文の間にはスペースをおいてくださ
い: >
	var name = value # コメント
	var name = value# エラー!

コメントを #{ で始めてはいけません。これは旧来の辞書リテラルのように見えるし、
混乱を招く可能性がある場所ではエラーが発生するからです。#{{ や #{{{ なら OK で
す。これらは折り畳みの開始に使用できます。

旧来の Vim script では # は代替ファイル名としても使われます。Vim9 scriptでは、
代わりに %% を使う必要があります。## の代わりに %%% を使います。(すべての引数
を意味します)


Vim9 関数 ~

`:def` で定義された関数はコンパイルされます。処理の実行は多くの場合、通常の関
数に比べて10倍から100倍ほど速くなります。

多くのエラーは関数が実行される前に、コンパイルされる段階で検出されます。読みや
すく理解しやすいコードを強制するために、構文は厳密に定められています。

コンパイルは以下のいずれかのタイミングで実行されます:
- 関数が最初に呼び出されるとき
- スクリプト内で関数の定義の後に `:defcompile` コマンドを見つけたとき
- 関数に対して `:disassemble` コマンドが実行されたとき
- コンパイルされた関数から呼び出されたり、関数リファレンスとして使用されたとき
							*E1091*
コンパイルが失敗した場合、次の呼び出し時に再実行はされません。代わりにこのエ
ラーが発生します: "E1091: Function is not compiled: {name}".
未作成のユーザー定義コマンドが見つかったときコンパイルは失敗します。この場合
`execute()` を使って実行時にコマンドを呼び出すことができます。 >
	def MyFunc()
	  execute('DefinedLater')
	enddef

`:def` には `:function` の "range"、"abort"、"dict" や "closure" といったオプ
ションがありません。`:def` で定義する関数はエラー時は常に(ただし、`:silent!`が
指定されたコマンドか、`:try` ブロックの中は除く)処理を中断し、渡される範囲を受
け取らない "dict" 関数にすることはできず、常にクロージャとすることができます。

後にクラスが追加され、"辞書関数" のメカニズムを置き換えることになります。現状
では辞書を明示的に渡す必要があります: >
	def DictFunc(d: dict<any>, arg: string)
	   echo d[arg]
	enddef
	var d = {item: 'value', func: DictFunc}
	d.func(d, 'item')

引数の型と戻り値の型を指定する必要があります。型には "any" を指定することがで
き、型のチェックは旧来の関数と同様に実行時に行われます。

引数を参照する際は、他のプログラミング言語と同様、"a:" をつけずに名前だけで指定
することができます。
引数辞書 "a:" と 引数リスト "a:000" はありません。
						*vim9-variable-arguments*
可変長引数を定義する場合は TypeScript のように、最後の引数として名前とlist型で
定義します。たとえば、数値の可変長引数の例は以下のとおりです: >
	def MyFunc(...itemlist: list<number>)
	   for item in itemlist
	     ...

関数の引数が省略可能な場合 (デフォルト値を持つ場合)、引数に `v:none` を渡すこ
とでデフォルト値を使用できます。これは、デフォルト値を使用する引数よりも後ろの
引数に値を指定したい場合に便利です。例: >
	def MyFunc(one = 'one', last = 'last')
	  ...
	enddef
	MyFunc(v:none, 'LAST')  # 第一引数はデフォルト値 'one' を使用する
<
						*vim9-ignored-argument*
引数 "_" (アンダースコア) を使うことで引数を無視できます。これは引数は要らない
が、呼び出しに合わせて引数を与える必要があるコールバックで最も便利です。例えば
map() ではキーと値の 2 つの引数が渡されますが、キーを無視するには次のようにし
ます: >
	map(myList, (_, v) => v * 2)
引数 "_" を複数回使用してもエラーにはなりません。また型を指定する必要はありま
せん。


関数と変数はデフォルトでスクリプトローカル ~
							*vim9-scopes*
Vim9 script でスクリプト直下に `:function` や `:def` を使って関数を定義すると、
関数はプリフィックス "s:" をつけた際のように、スクリプトローカルで定義されま
す。"s:" を明示することもできます。グローバルスコープの関数や変数を定義するに
はプリフィックス "g:" をつける必要があります。オートロードスクリプトで定義する
場合は、"name#" をつけます。 >
	def ThisFunction()          # スクリプトローカル
	def s:ThisFunction()        # スクリプトローカル
	def g:ThatFunction()        # グローバル
	def scriptname#function()   # オートロード

`:def` で定義した関数の中で `:function` や `:def` でネストした関数を定義するこ
とができ、定義されたブロックローカルのスコープになります。
`:def` で定義した関数の中では、スクリプトのスコープで関数を定義することはでき
ません。プリフィックス "g:" を使ってグローバルスコープの関数を定義することはで
きます。

関数をプリフィックス "s:" や "g:" をつけずに参照した場合、Vim は関数を次のよう
に探します:
- 同じ関数の中、ブロックスコープの中
- スクリプトスコープの中、インポートされたもの
- グローバル関数のリスト
しかし、明瞭にするためにもグローバル関数を参照する際はプリフィックス "g:" を付
けることを推奨します。

スクリプトローカルな関数は "s:" なしでも参照できるので、プリフィックス "s:" を
付ける場合でも名前は大文字で始めなければなりません。旧来のスクリプトでは
"s:funcref" が使えましたが、これは "funcref" で参照できなかったからです。Vim9
script では参照できるので、名前が組み込み関数と干渉するのを避けるために
"s:Funcref" を使う必要があります。

いずれの場合でも、関数は使用されるよりも前に定義されていなくてはなりません。使
用されるタイミングは、コマンド `:defcompile` によってコンパイルされるとき、ま
たは関数を呼び出す関数がコンパイルされているとき（戻り値の型を確認するため）で
す。

その結果として、名前空間を持たない関数や変数は通常、スクリプト内で定義されてい
るか、インポートされたものかのどちらかで見つけることができます。グローバルな関
数や変数はどこでも定義できます（どこで定義されているか、見つかるといいです
ね！）。

グローバル関数は引き続き、ほとんどいつでも定義し、削除することができます。Vim9
script でのスクリプトローカル関数は、スクリプトが読み込まれたときに一度定義さ
れたきり、削除や置き換えはできません。

関数のコンパイルや、関数の呼び出しが未定義の関数に遭遇したとき、自動コマンド
|FuncUndefined| は呼び出されません。必要であればオートロード関数を使用したり、
旧来の関数を呼び出すことで |FuncUndefined| イベントが発生します。


デフォルトでは Vim9 script の再読み込みにより関数と変数がクリアされる ~
							*vim9-reload*
旧来の Vim script を2回目に読み込んだときは、何も削除されることはなく、コマン
ドはすでにある変数や関数を置き換えて新しいものを作ります。

Vim9 script を2回目に読み込んだときは、存在するすべてのスクリプトローカルの関
数や変数は削除され、クリーンな状態から開始します。これはプラグインを開発中に、
新しいバージョンを試す際には便利です。いずれかの名前を変えたとしても、古い名前
が残る心配はありません。

消さずに残すには、以下を使用します: >
	vim9script noclear

これを使用することで、再読み込みの際に任意の場所で `finish` コマンドにより脱出
することができます。たとえば、バッファローカルオプションが設定されているとき: >
	vim9script noclear
	setlocal completefunc=SomeFunc
	if exists('*g:SomeFunc') | finish | endif
	def g:SomeFunc()
	....


:var、:final や :const で宣言する変数 ~
						*vim9-declaration* *:var*
ローカル変数は `:var` で定義する必要があります。ローカル定数は `:final` または
`:const` で定義する必要があります。このセクションでは、両者を "変数" と呼ぶこ
とにします。

変数はスクリプトローカルや、関数、コードブロックのスコープで定義できます: >
	vim9script
	var script_var = 123
	def SomeFunc()
	  var func_var = script_var
	  if cond
	    var block_var = func_var
	  ...

変数は、定義されたコードブロックか、ネストされた配下のブロックで参照することが
できます。コードブロックが終わったあとの処理から参照することはできません: >
	if cond
	   var inner = 5
	else
	   var inner = 0
	endif
	echo inner  # エラー!

参照したい場合には、ブロックよりも前で宣言しなくてはなりません: >
	var inner: number
	if cond
	   inner = 5
	else
	   inner = 0
	endif
	echo inner

意図的に続く処理から変数を隠したいとき、ブロックを使うことができます: >
	{
	   var temp = 'temp'
	   ...
	}
	echo temp  # エラー!

変数を型付きで、かつ初期値なしで宣言した場合、その値はゼロ、False、または空で
初期化されます。

Vim9 script では `:let` は使用できません。既存の変数にはコマンドを使用せずに代
入します。グローバル変数、ウィンドウ変数、タブ変数、バッファ変数、そして Vim
の定義済変数についても同様です。これらは実は宣言されないからです。またこれらは
`:unlet` で削除できます。

`:lockvar` はローカル変数に対しては動作しません。代わりに `:const` か `:final`
を使ってください。

変数と関数と関数の引数は、同じスクリプトファイル内で、すでに定義された、または
インポートされた変数と関数をシャドーイングすることはできません。一方で変数は
Ex コマンドをシャドーイングするので、必要であれば変数の名前を変更してくださ
い。

グローバル変数にはスクリプトレベルでも "g:" を付けなければなりません。 >
	vim9script
	var script_local = 'text'
	g:global = 'value'
	var Funcref = g:ThatFunction

グローバル関数には定義の際には "g:" を付けなければなりませんが、"g:" なしでも
呼び出せます: >
	vim9script
	def g:GlobalFunc(): string
	  return 'text'
	enddef
	echo GlobalFunc()
プリフィックス "g:" はオートロード関数には必要ありません。

現在、`&opt = value` は "opt" オプションに値を設定する目的で使用されているた
め、`:substitute` コマンドをリピートする目的 ":&" を使用することはできません。
							*vim9-unpack-ignore*
アンパック代入ではアンダースコアを使うことでリストの要素を無視できます。関数の
引数を無視する方法と同様です: >
	[a, _, c] = theList
残りの要素を全て無視するには: >
	[a, b; _] = longList

<							*E1092*
変数を複数一度に宣言し、同時にアンパックする記法は現在サポートされていません: >
	var [v1, v2] = GetValues()  # エラー!
これは、リストの要素から型を推定せねばならず、現在はそれが容易ではないからで
す。

定数 ~
						*vim9-const* *vim9-final*
定数の働きは言語によって異なります。別の値を代入できない変数を定数とする場合も
あります。JavaScript がその一例です。また、値そのものを不変にすることもあり、
たとえばリスト定数の内容を変更することができないとしている場合もあります。
Vim9ではこのどちらも定義することができます。

変数とその値、両方を定数とするには、`:const` を使用します。何らかの複合的な値
が変更できないようにする際に使用します。例: >
	const myList = [1, 2]
	myList = [3, 4]		# エラー!
	myList[0] = 9		# エラー!
	myList->add(3)		# エラー!
<							*:final*
変数の変更のみを禁止するには、`:final` を使用します。この場合は、中の値自体を
変えることはできます。Java でよく知られるものです。例: >
	final myList = [1, 2]
	myList = [3, 4]		# エラー!
	myList[0] = 9		# OK
	myList->add(3)		# OK

一般に、定数はすべて大文字 (例: ALL_CAPS) で書かれますが、必ずしもそうしなくて
も構いません。

定数宣言は値そのものにのみ適用され、参照先の変数には影響しません。 >
	final females = ["Mary"]
	const NAMES = [["John", "Peter"], females]
	NAMES[0] = ["Jack"]     # エラー!
	NAMES[0][0] = "Jack"    # エラー!
	NAMES[1] = ["Emma"]     # エラー!
	NAMES[1][0] = "Emma"    # OK, females[0] == "Emma"


:call と :eval は不要に ~

関数は `:call` なしで呼ぶことができます: >
	writefile(lines, 'file')
`:call` は引き続き使用できますが、やめたほうが良いでしょう。

メソッド呼び出しには `eval` は必要ありません。Exコマンドと同名の識別子ではない
限り、直接に識別子から呼び出すことができます。関数の場合は、"(" または "->"の
どちらかを改行せずに続けなければなりません。例: >
	myList->add(123)
	g:myList->add(123)
	[1, 2, 3]->Process()
	{a: 1, b: 2}->Process()
	"foobar"->Process()
	("foobar")->Process()
	'foobar'->Process()
	('foobar')->Process()

一部の関数と Ex コマンドが紛らわしい場合、コロン (:) を前置することでそれが Ex
コマンドであることを明示することができます。たとえば、`:substitute` コマンドと
`substitute()` が該当します。`substitute(` で始まる場合は関数呼び出しですが、
コロンを前置することでコマンドを代わりに使用することができます: >
	:substitute(pattern (replacement (

Note 変数は使用する前に宣言する必要がありますが、関数は宣言するより前に使用で
きる点に注意してください。これは関数の循環参照を可能にするためです。関数を名前
で探さなければならないので、少し効率が悪いです。また、関数名のタイプミスは、関
数が呼び出されるときまで見つかりません。


function() は不要に ~

ユーザー定義の関数は、`function()` を使わずとも関数リファレンスとして使用する
ことができます。引数の型と戻り値の型がチェックされます。関数はすでに定義されて
いる必要があります。 >

	var Funcref = MyFunction

`function()` を使って "func" 型のリファレンスを得た場合、その関数は任意の個数
の引数と任意の戻り値の型を持つものとされます。この場合、関数は後から宣言できま
す。


ラムダ式には -> の代わりに => を使う ~
							*vim9-lambda*
旧来のスクリプトでは "->" はメソッド呼び出しとラムダ式で混同するおそれがありま
す。また、"{" が見つかったとき、パーサーはラムダ式と辞書の開始を見分けねばなら
ず、そしてそれは引数の型指定により複雑になっています。

この問題を回避するため、Vim9 script ではラムダ式のために違う書式を使用し、それ
は JavaScript に似ています: >
	var Lambda = (arg) => expression

"=>" まで含めて、ラムダ式の引数の定義の中では改行することはできません (Vim が
括弧内の式とラムダの引数を区別できるようにするためです)。これは OKです: >
	filter(list, (k, v) =>
			v > 0)
以下のように記述することはできません: >
	filter(list, (k, v)
			=> v > 0)
以下のように記述することもできません: >
	filter(list, (k,
			v) => v > 0)
ただし、バックスラッシュを使ってパースする前に行をつなげることができます: >
	filter(list, (k,
		\	v)
		\	=> v > 0)
<							*vim9-lambda-arguments*
旧来のスクリプトではラムダ式は余分な引数をいくつ与えても呼び出せるうえ、それら
が使われていないことを警告する方法はありませんでした。Vim9 script では引数の個
数は一致しなければなりません。任意個の引数や任意個の追加の引数を受け取りたい場
合は "..._" を使います。これにより関数は可変長引数 |vim9-variable-arguments|
を受け取れるようになります。例: >
	var Callback = (..._) => 'anything'
	echo Callback(1, 2, 3)  # "anything" を表示する

<							*inline-function*
加えて、ラムダ式には {} に複数のステートメントを含むことができます: >
	var Lambda = (arg) => {
		g:was_called = 'yes'
		return expression
	    }
これはタイマーを使うときに便利です。例: >
	var count = 0
 	var timer = timer_start(500, (_) => {
		 count += 1
		 echom 'Handler called ' .. count
	     }, {repeat: 3})


終端の "}" は行頭になければなりません。後ろに他の文字を続けることは可能です。
例: >
	var d = mapnew(dict, (k, v): string => {
	     return 'value'
	   })
"{" の後ろにコマンドを続けることはできません。続けられるのはコメントだけです。

理由: "}" をコマンドの後ろに置けないのは、それを許すとコマンドのパース時に "}"
を探さなければならなくなるからです。これとの一貫性のため "}" の後ろにコマンド
を続けられないようにしています。残念ながら、これは "() => {  command  }" が動
作しないことを意味します。常に改行が必要です。

							*vim9-curly*
辞書リテラルの "{" がステートメントブロックと認識されてしまうのを回避するため
には、括弧で包みます: >
	var Lambda = (arg) => ({key: 42})

さらに、コマンドブロックの開始と混同してしまう場合: >
	({
	    key: value
	 })->method()


自動行継続 ~

多くの場合、式が次の行に続くことは明らかです。継続行の先頭に行継続のためのバッ
クスラッシュ (|line-continuation| 参照) を置く必要はありません。たとえば、複数
行にまたぐリストの場合: >
	var mylist = [
		'one',
		'two',
		]
辞書の場合: >
	var mydict = {
		one: 1,
		two: 2,
		}
関数の呼び出し: >
	var result = Func(
			arg1,
			arg2
			)

角カッコ []、波カッコ {}、または丸カッコの中‘以外で’二項演算子御使用する場
合、その前後で改行することができます。例: >
	var text = lead
		   .. middle
		   .. end
	var total = start +
		    end -
		    correction
	var result = positive
			? PosFunc(arg)
			: NegFunc(arg)

"->" を使用したメソッド呼び出し、そしてドット (.) を使用したメンバー参照の場
合、その前に改行を置くことができます: >
	var result = GetBuilder()
			->BuilderSetWidth(333)
			->BuilderSetHeight(777)
			->BuilderBuild()
	var result = MyDict
			.member

複数のコマンドのリストを引数に持つコマンドでは、行の先頭に置かれた文字 | は行
継続を表します: >
	autocmd BufNewFile *.match if condition
		|   echo 'match'
		| endif

Note これは heredoc の最初の行はバーにできない {訳注: | で始められない} ことを
意味します: >
	var lines =<< trim END
	   | this doesn't work
	END
最初に空行を使うか heredoc を使わないようにしてください。あるいは 'cpoptions'
に一時的に "C" フラグを追加してください: >
	set cpo+=C
	var lines =<< trim END
	   | this works
	END
	set cpo-=C
heredoc が関数内にある場合、'cpoptions' は :def の前で設定し :enddef の後ろで
復元しなければなりません。

長い Ex コマンドの分割など、バックスラッシュによる行継続が依然として必要な場所
では、コメントを "\ ではなく #\ で開始できます: >
      syn region Text
	      \ start='foo'
	      #\ comment
	      \ end='bar'

<							*E1050*
行頭の演算子と識別できるようにするために、範囲指定の前にはコロンを置きま
す。"start" と print をつなげる例: >
	var result = start
	+ print
これは以下の記述と同じです: >
	var result = start + print

次のように書くと、"start" を代入して、1行表示します: >
	var result = start
	:+ print

Note |+cmd| の引数にはコロンは不要です: >
	edit +6 fname

関数の定義部においても、引数の間で改行をおくことができます: >
	def MyFunc(
		text: string,
		separator = '-'
		): string

継続行を識別することは容易ではないため、コマンドの解析はより厳格化されていま
す。たとえば、一行目のエラーにより、2行目は別のコマンドとみなされます: >
	popup_create(some invalid expression, {
	   exit_cb: Func})
ここで "exit_cb: Func})" は実際に有効なコマンドです: 変更をファイル
"_cb: Func})" に保存して閉じます。Vim9 script の中ではこの種のミスを回避するた
めに、コマンド名と引数の間にはスペースを置かなくてはなりません。

ただし、コマンドの引数に置いたコマンドは認識されません。たとえば、
"windo echo expr" に続く "expr" の式の中で改行しても認識されません。


Notes:
- "enddef" は継続行の先頭に置くことはできません。それは関数の終端を意味します。
- 代入式の左辺を複数の行に分割できません。特にリストのアンパック |:let-unpack|
  を使用する場合は注意が必要です。これはOKです: >
	[var1, var2] =
		Func()
<  以下のように記述することはできません: >
	[var1,
	    var2] =
		Func()
- `:echo` や `:execute` のようなコマンドの引数は複数の行に分割できません。これ
  はOKです: >
	echo [1,
		2] [3,
			4]
<  以下のように記述することはできません: >
	echo [1, 2]
		[3, 4]
- Vim がコマンドをパースするのが難しい場合があります。特にコマンドが `windo`
  のような他のコマンドの引数として使われている場合です。そのような場合にはバッ
  クスラッシュによる行継続を使用しなければなりません。


スペース ~

Vim9 script ではスペースの適切な使用を推奨しています。以下のような記述はできま
せん: >
	var name=234	# エラー!
	var name= 234	# エラー!
	var name =234	# エラー!
"=" の前後にはスペースを置く必要があります: >
	var name = 234	# OK
コメント先頭の # の前にもスペースが必要です: >
	var name = 234# エラー!
	var name = 234 # OK

多くの演算子の前後にはスペースが必要です。

部分リストの ":" の前後には、先頭と末尾の場合を除いてはスペースが必要です: >
	otherlist = mylist[v : count]  	# v:count は違う意味になる
	otherlist = mylist[:]		# リストのコピーを作る
	otherlist = mylist[v :]
	otherlist = mylist[: v]

スペースをおいてはいけない場合:
- 関数の名前と "(" の間: >
	Func (arg)	   # エラー!
	Func
	     \ (arg)	   # エラー!
	Func
	      (arg)	   # エラー!
	Func(arg)	   # OK
	Func(
	      arg)	   # OK
	Func(
	      arg	   # OK
	      )


波括弧変数の廃止 ~

波括弧変数 |curly-braces-names| は使用できません。


辞書リテラル ~

従来、Vim は波括弧 {} で辞書リテラルの表記をサポートしてきました: >
	let dict = {'key': value}

後に、辞書にシンプルなキーを使用することが非常に一般的であることが明らかになっ
たため、キーをクォーテーションなしで指定できる表記が後方互換的に導入されまし
た: >
	let dict = #{key: value}

しかし、この #{} という表記は他の言語に比べて異色なものです。キーには式よりも
リテラルを使うほうが一般的で、JavaScript が使っている構文を考えると、辞書リテ
ラルに {} の表記を使うほうがずっと便利です: >
	var dict = {key: value}

これは英数字、アンダースコアとダッシュのキーで利用できます。異なる文字を使用す
る場合は、シングルクォートまたはダブルクォートで囲まれた文字列を使用します: >
	var dict = {'key with space': value}
	var dict = {"key\twith\ttabs": value}
	var dict = {'': value}  		# 空のキー

キーに式を使用する必要がある場合は、JavaScript と同様に角括弧を使用することが
できます: >
	var dict = {["key" .. nr]: value}

キーの型には、文字列、数値、bool、floatのいずれかを指定できます。その他の型の
場合はエラーが発生します。数字は、[] をつけてもつけなくても与えられます: >
	var dict = {123: 'without', [456]: 'with'}
	echo dict
	{'456': 'with', '123': 'without'}

:xit、:t、:k、:append、:change、:insert の廃止 ~

これらのコマンドは容易にローカル変数の名前と混同します。
`:x` や `:xit` の代わりに `:exit` を使用できます。
`:t` の代わりに `:copy` を使用できます。
`:k` の代わりに `:mark` を使用できます。

比較 ~

オプション 'ignorecase' は文字列の比較には作用しません。


エラー後に中断される ~

旧来のスクリプトでは、エラーが発生しても Vim は後続の行を実行し続けます。その
ためエラーが連続して発生し、CTRL-C で停止せざるを得なくなることがあります。
Vim9 script ではコマンドの実行は最初のエラーで停止します。例: >
	vim9script
	var x = does-not-exist
	echo 'not executed'


For ループ ~

旧来の Vim script では、リストのループ内で現在または前の項目を削除するための
for ループをつくるために幾つかのトリックがあります。Vim9 script では、単純にイ
ンデックスを使用することで、リストから削除された場合はスキップされます。
旧来のスクリプトの例: >
	let l = [1, 2, 3, 4]
	for i in l
	   echo i
	   call remove(l, index(l, i))
	endfor
出力は以下の通り:
	1
	2
	3
	4
コンパイルされた Vim9 スクリプトでの出力は以下の通り:
	1
	3
一般的に、反復しているリストを変更してはいけません。必要であれば最初にコピーを
作ります。


条件と式 ~

条件と式は、他の言語とおよそ同じように扱われます。いくつかの値は旧来の Vim
script と扱いが異なります:
	値		旧来の Vim script	Vim9 script ~
	0		falsy			falsy
	1		truthy			truthy
	99		truthy			エラー!
	"0"		falsy			エラー!
	"99"		truthy			エラー!
	"text"		falsy			エラー!

"??" 演算子か "!" を使用している場合はエラーとなることはなく、すべての値は
falsy か truthy として評価されます。これは JavaScript とほぼ同じですが、空の
リストと辞書は falsy として評価されます:

	型		真と評価される値 ~
	bool		true, v:true または 1
	number		非0
	float		非0
	string		空文字列以外
	blob		空ブロブ以外
	list		空リスト以外 (JavaScript とは異なります)
	dictionary	空辞書以外 (JavaScript とは異なります)
	func		when there is a function name
	special		true または v:true
	job		非 NULL
	channel		非 NULL
	class		非 NULL
	object		非 NULL (TODO: isTrue() が true を返すとき)

真偽値演算子 "||" と "&&" は、値が真偽値、0または1であることを期待します:
>
	1 || false   == true
	0 || 1       == true
	0 || false   == false
	1 && true    == true
	0 && 1       == false
	8 || 0	     エラー!
	'yes' && 0   エラー!
	[] || 99     エラー!

"!" を使って論理否定をすると、どのような型に対しても結果は真偽値になります。
"!!" と二重論理否定をすることで、あらゆる型を真偽値に変換することができます: >
	!'yes'			== false
	!![]			== false
	!![1, 2, 3]		== true

文字列の結合に `..` を使用すると、すべての単純型の被演算子は常に文字列に変換さ
れます: >
	'hello ' .. 123  == 'hello 123'
	'hello ' .. v:true  == 'hello true'

単純型とは、文字列 (string)、数値 (float)、特殊値 (special) と真偽値 (bool) で
す。他の型では |string()| が使用できます。

							*false* *true* *null*
Vim9 script では "true" を v:true として、"false" を v:false として、そして
"null" を v:null として使うことができます。真偽値を文字列に変換するとき、旧来
のスクリプトのような "v:false" と "v:true" ではなく、"false" と "true" を使用
します。"v:none" は変わらず、JSONでのみ使用され、他の言語には相当するものはあ
りません。

文字列に対してインデックス [idx] や [idx : idx] を使用すると、バイト単位ではな
く文字単位のインデックスとして扱われます。結合文字が含まれています。例: >
	echo 'bár'[1]
旧来の Vim script ではこれは文字 0xc3 (不正な文字) となりますが、Vim9 script
では文字列 'á' が得られます。
負のインデックスを指定すると、文字列の末尾から数えられます。"[-1]" は最後の文
字です。
最後の文字を除外するには |slice()| を使用します。
合成文字を別々に数えるには |strcharpart()| を使用します。
インデックスが範囲外の場合は、空文字列になります。

旧来のスクリプトでは "++var" と "--var" は寡黙に処理され、何の効果ももたらしま
せん。これは Vim9 script ではエラーになります。

ゼロから始まる数値は8進数とはみなされません、"0o" から始まる数値だけが8進数と
みなされます: "0o744"。|scriptversion-4|


気をつけるべきこと ~
							*vim9-gotchas*
Vim9 は、一般的なプログラミング言語に近づくように設計されていますが、同時に旧
来の Vim コマンドをサポートしようとしています。そのため、いくつかの妥協をしな
ければなりませんでした。ここでは、意外と知られていないことをまとめてみました。

Exコマンドの範囲指定にはコロンを前置する必要があります。 >
	->		  旧来の Vim: 前の行を右にシフト
	->func()	  Vim9: 継続行におけるメソッド呼び出し
	:->		  Vim9: 前の行を右にシフト

	%s/a/b		  旧来の Vim: すべての行を置換
	x = alongname
	     % another	  Vim9: 継続行の剰余演算
	:%s/a/b		  Vim9: すべての行を置換
	't		  旧来の Vim: マーク t へのジャンプ
	'text'->func()	  Vim9: メソッド呼び出し
	:'t		  Vim9: マーク t へのジャンプ

いくつかのExコマンドは Vim9 script の代入式と紛らわしくなります: >
	g:name = value    # 代入
	g:pattern:cmd	  # 不正なコマンド - エラー
	:g:pattern:cmd	  # :グローバルコマンド

`:def` で定義した関数はすべてコンパイルされます。旧来の関数は途中で脱出するこ
とができ、それ以降の行はパースされません: >
	func Maybe()
	  if !has('feature')
	    return
	  endif
	  use-feature
	endfunc
Vim9 関数はすべてコンパイルされます: >
	def Maybe()
	  if !has('feature')
	    return
	  endif
	  use-feature  # コンパイルエラーが発生する可能性がある
	enddef
応急的に、2つの関数に分けることができます: >
	func Maybe()
	  if has('feature')
	    call MaybeInner()
	  endif
	endfunc
	if has('feature')
	  def MaybeInner()
	    use-feature
	  enddef
	endif
また、偽として評価される定数式の条件をもった `if` の配下にサポート外のコードを
置くことができます: >
	def Maybe()
	  if has('feature')
	    use-feature
	  endif
	enddef
<							*vim9-user-command*
関数のコンパイルによる他の副作用として、ユーザーコマンドの存在がコンパイルの時
点でチェックされます。ユーザーコマンドが後で定義されている場合、エラーとなりま
す。これはOKです: >
	command -nargs=1 MyCommand echom <q-args>
	def Works()
	  MyCommand 123
	enddef
これは "MyCommand" が定義されていないというエラーが発生します: >
	def Works()
	  command -nargs=1 MyCommand echom <q-args>
	  MyCommand 123
	enddef
回避策は、`:execute` を使用して間接的にコマンドを呼び出すことです: >
	def Works()
	  command -nargs=1 MyCommand echom <q-args>
	  execute 'MyCommand 123'
	enddef

Note 認識されていないコマンドを "|" でつなぐと、その後のコマンドは認識されませ
ん。次のような記述は `endif` がないというエラーになります: >
	def Maybe()
	  if has('feature') | use-feature | endif
	enddef

その他の変更点 ~

パターンは、明示的に上書きされない限り 'magic' が設定されている状態と同様に作
用します。
オプション 'edcompatible' の値は使用されません。
オプション 'gdefault' の値は使用されません。

また、このwikiも参考になるでしょう。これはVim9 scriptのアーリーアダプターによっ
て書かれました: https://github.com/lacygoill/wiki/blob/master/vim/vim9.md

==============================================================================

3. 新しいスタイルの関数					*fast-functions*

THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE

							*:def*
:def[!] {name}([arguments])[: {return-type}]
			新しい関数を {name} という名前で定義します。関数の本体
			は、次の行から対応する `:enddef` まで続きます。

			{return-type} が省略されたか "void" である場合、関数は
			何も返さないことが期待されます。

			{arguments} は引数の宣言を 0 個以上並べたものです。3
			つの形式があります:
				{name}: {type}
				{name} = {value}
				{name}: {type} = {value}
			1 番目の形式は必須の引数を表し、呼び出し側でそれらを渡
			す必要があります。
			2 番目と 3 番目の形式は省略可能な引数を表します。呼び
			出し側で引数を省略した場合 {value} が使われます。

			関数は呼び出されたとき、または `:disassemble` か
			`:defcompile` が使用されたときに命令にコンパイルされま
			す。構文と型のエラーはこのときに発生します。

			他の `:def` や `:function` の内側で `:def` を深さ 50
			までネストできます。

			[!] は `:function` と同様に使用されます。Note Vim9
			script ではスクリプトローカルな関数を後から削除したり
			再定義したりすることができません。同じスクリプトを再読
			み込みすることでのみ除去できます。

							*:enddef*
:enddef			`:def` で定義された関数の終了です。1 行にこれだけを書
			くようにしてください。

この wiki も参考になるでしょう。これは Vim9 script のアーリーアダプターによっ
て書かれました: https://github.com/lacygoill/wiki/blob/master/vim/vim9.md

関数が定義されているスクリプトが Vim9 script である場合、{訳注: 関数内から} ス
クリプトローカルな変数にプリフィックス "s:" なしでアクセスできます。ただしスク
リプトローカルな変数は関数のコンパイル時には定義されていなければなりません。関
数が定義されているスクリプトが旧来のスクリプトで、コンパイル時に変数が未定義と
なる場合は "s:" を付ける必要があります。

						*:defc* *:defcompile*
:defc[ompile]		現在のスクリプトで定義された、まだコンパイルされていな
			い関数をコンパイルします。
			これはコンパイル時に見つかったエラーを報告します。

						*:disa* *:disassemble*
:disa[ssemble] {func}	{func} に対して生成された命令を表示します。
			これはデバッグとテスト用です。
			Note コマンドラインで {func} を補完するとき、"s:" を前
			置することでスクリプトローカルな関数を見つけることがで
			きます。

:disa[ssemble] profile {func}
			`:disassemble` と同様ですが、プロファイリング用の命令
			も表示します。

:disa[ssemble] debug {func}
			`:disassemble` と同様ですが、デバッグ用の命令も表示し
			ます。

制約 ~

ローカル変数は文字列の評価結果の式からは見えなくなります。例: >
	def MapList(): list<string>
	  var list = ['aa', 'bb', 'cc', 'dd']
	  return range(1, 2)->map('list[v:val]')
	enddef

この map の引数は式を表す文字列ですが、式の評価は関数スコープの外で行われます。
代わりにラムダ式を使ってください: >
	def MapList(): list<string>
	  var list = ['aa', 'bb', 'cc', 'dd']
	  return range(1, 2)->map((_, v) => list[v])
	enddef

同じことが `:global` のようなコンパイルされないコマンドに対しても言えます。こ
れにはバッククォート展開が使えます。例: >
	def Replace()
	  var newText = 'blah'
	  g/pattern/s/^/`=newText`/
	enddef

ループの内側で定義された複数のクロージャは同じコンテキストを共有します。例: >
	var flist: list<func>
	for i in range(10)
	  var inloop = i
	  flist[i] = () => inloop
	endfor

変数 "inloop" が作成されるのは一度だけです。リストに格納される全てのクロージャ
は、最終的に値が 9 となる同じインスタンスを参照します。これは効率的です。クロー
ジャごとに個別のコンテキストが必要な場合は、それを定義する関数を呼び出すように
してください: >
	def GetFunc(i: number): func
	  var inloop = i
	  return () => inloop
	enddef

	var flist: list<func>
	for i in range(10)
	  flist[i] = GetFunc(i)
	endfor

==============================================================================

4. 型						*vim9-types*

THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE

以下の組み込み型がサポートされています:
	bool
	number
	float
	string
	blob
	list<{type}>
	dict<{type}>
	job
	channel
	func
	func: {type}
	func({type}, ...)
	func({type}, ...): {type}

これはまだサポートされていません:
	tuple<a: {type}, b: {type}, ...>

これらの型は宣言時に使用できますが、値がこの型を持つことはありません:
	{type}|{type}  {not implemented yet}
	void
	any

array 型はありません。代わりに list<{type}> を使います。リスト定数には効率的な
実装が使われており、小さなメモリがたくさん確保されないようになっています。

部分適用と関数は多かれ少なかれ具体的な方法で宣言できます:
func				任意の種類の関数です。引数や戻り値に対して型
				チェックは行われません
func: {type}			引数の個数と型は任意で、特定の戻り値の型を持ち
				ます
func({type})			引数の型を持つ関数です。値は返しません
func({type}): {type}		引数の型と戻り値の型を持つ関数です
func(?{type})			省略可能な引数の型を持つ関数です。値は返しませ
				ん
func(...{type})			可変長引数の型を持つ関数です。値は返しません
func({type}, ?{type}, ...{type}): {type}
				次の要素を持つ関数です:
				- 必須の引数の型
				- 省略可能な引数の型
				- 可変長引数の型
				- 戻り値の型

戻り値の型が "void" である場合、関数は値を返しません。

関数への参照は部分適用 |Partial| にすることもできます。その場合、参照は追加の
引数や辞書を保持していますが、呼び出し側からは見えません。部分適用は同じ方法で
呼び出されるので宣言の仕方も同じです。

カスタム型は `:type` で定義できます: >
	:type MyList list<string>
カスタム型は大文字で始めなければなりません。これは後から追加される組み込み型と
名前が衝突するのを防ぐためで、ユーザー定義関数と同様です。
{not implemented yet}

クラスとインターフェイスは型として使用できます: >
	:class MyClass
	:var mine: MyClass

	:interface MyInterface
	:var mine: MyInterface

	:class MyTemplate<Targ>
	:var mine: MyTemplate<number>
	:var mine: MyTemplate<string>

	:class MyInterface<Targ>
	:var mine: MyInterface<number>
	:var mine: MyInterface<string>
{not implemented yet}


変数の型と型キャスト ~
							*variable-types*
Vim9 script や `:def` 関数内で宣言された変数は型を持ちます。型は明示的に指定さ
れるか、変数の初期化から推論されます。

グローバル変数、バッファローカル変数、ウィンドウローカル変数およびタブページ
ローカル変数は特定の型を持ちません。値はいつでも変更可能で、型を変更することも
できます。そのためコンパイルされたコードでは "any" 型であると仮定されます。

これは "any" 型が望ましくなく、実際の型が常に同じであることが期待される場合に
問題になります。例えばリストを宣言するとき: >
	var l: list<number> = [1, g:two]
Vim はコンパイル時に "g:two" の型を知らないので、式の型は list<any> になってし
まいます。代入の前にリストの型をチェックする命令が生成されますが、これは少し効
率が悪いです。
							*type-casting*
これを回避するには型キャストを使います: >
	var l: list<number> = [1, <number>g:two]
コンパイルされたコードは ":g:two" が数値であることだけをチェックし、そうでない
場合にエラーを報告します。これを型キャストと呼びます。

型キャストの構文は: "<" {type} ">" です。"<" の後ろや ">" の前に空白を入れるこ
とはできません (smaller-than 演算子や bigger-than 演算子との混同を避けるためで
す)。

セマンティクスとは、実行時に必要に応じて型チェックを行うことをいいます。実際に
値が変更されることはありません。型を変更する必要がある場合、例えば文字列に変更
する場合は |string()| 関数を使います。文字列を数値に変換するには |str2nr()| を
使います。


型推論 ~
							*type-inference*
一般的に: 型が明らかな場合は型を省略できます。例えば変数を宣言して値を与える場
合です: >
	var name = 0		# 数値型であると推論されます
	var name = 'hello'	# 文字列型であると推論されます

リストと辞書の型はその要素の共通の型で決まります。すべての要素が同じ型を持つ場
合、その型がリストまたは辞書の型として使われます。型が混在している場合は "any"
型が使われます。 >
	[1, 2, 3]	list<number>
	['a', 'b', 'c']	list<string>
	[1, 'x', 3]	list<any>

Vim9 script のスクリプトローカルな変数に対する型チェックは、変数が旧来の関数内
で宣言された場合にも行われます。


より厳密な型チェック ~
							*type-checking*
旧来の Vim script では、数値が期待される場所で文字列が自動的に数値に変換されま
した。これは文字列が "123" のような実際の数字である場合には便利でしたが、文字
列が数字で始まらない場合に予期せぬ問題を引き起こします (エラーメッセージも表示
されません)。その結果、発見が困難なバグが発生することも少なくありません。

Vim9 script では型チェックがより厳密になりました。ほとんどの場所で以前と同様に
動作しますが、値が期待の型に一致しない場合はそうとは限りません。時にはエラーが
発生するため、後方互換性が失われています。例:
- 真偽値が期待される場所で 0 または 1 以外の数値が使用されています。 *E1023*
- 数値オプションの設定に文字列が使用されています。
- 文字列が期待される場所で数値が使用されています。 *E1024*

結果的に map() に渡すリストや辞書の要素の型は変更できなくなりました。これは
Vim9 script ではエラーになります: >
	map([1, 2, 3], (i, v) => 'item ' .. i)
	E1012: Type mismatch; expected number but got string
代わりに |mapnew()| を使ってください。要素の型が "any" である場合は {訳注:
map() を使って} 要素の型を数値型などの特定の型に変更できます。同じことが
|extend()| と |flatten()| にも言えます。代わりに |extendnew()| と
|flattennew()| を使ってください。

==============================================================================

5. 名前空間、インポートとエクスポート
					*vim9script* *vim9-export* *vim9-import*

THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE

Vim9 script を書いて、それをインポートすることができます。これはエクスポートさ
れない限り、スクリプト内のすべてのアイテムがローカルになることを意味します。他
のスクリプトでインポートできるのはエクスポートされたアイテムだけです。

グローバルな名前空間を明示的に使用して誤魔化すことはできますが、ここではそのよ
うなことはしないと仮定しましょう。


名前空間 ~
							*vim9-namespace*
ファイルをインポートできるものとして識別させるには `vim9script` 文がファイルの
最初の文として現れなければなりません (例外については |vim9-mix| を参照)。これ
は、スクリプトをグローバルな名前空間ではなく独自の名前空間で解釈するように Vim
に指示します。ファイルが次の内容で始まる場合: >
	vim9script
	var myvar = 'yes'
"myvar" が存在するのはこのファイル内だけです。`vim9script` がない場合は他のス
クリプトや関数内で `g:myvar` として使用できます {訳注: var は let に変える必要
があります}。

ファイルレベルの変数は旧来の Vim script のスクリプトローカルな "s:" 変数に非常
によく似ていますが、"s:" は省略されます。また削除することはできません。

Vim9 script ではグローバルな名前空間 "g:" を以前と同様に使用できます。名前空間
"w:"、"b:"、"t:" についても同様です。これらには、変数は宣言されず、削除できる
という共通点があります。

`:vim9script` の副作用として、'cpoptions' オプションが Vim のデフォルト値に設
定されます。これと同等です: >
	:set cpo&vim
この効果の一つは行継続 |line-continuation| が常に有効になることです。
'cpoptions' の元の値はスクリプトの最後に復元されますが、スクリプトで追加・削除
されたフラグは元の値に対して追加・削除されるので同じ効果が得られます。またフラ
グの順序は変わることがあります。

							*vim9-mix*
一つのスクリプトファイルで旧来の構文と Vim9 の構文の両方を使用する方法がありま
す: >
	" ここにコメントが書けます
	if !has('vim9script')
	   " 旧来のスクリプトのコマンドをここに書きます
	   finish
	endif
	vim9script
	# Vim9 script のコマンドをここに書きます
こうすることで可能であれば Vim9 script の構文を利用できます。また、このスクリ
プトは Vim9 script がないバージョンの Vim でも動作するでしょう。

可能な動作は次の 2 通りだけです:
1. "if" 文が偽と評価され、`endif` までのコマンドがスキップされて `vim9script`
   が実際に実行される最初のコマンドになります。
2. "if" 文が真と評価され、`endif` までのコマンドが実行されて `finish` により
   `vim9script` に到達する前に終了します。

TODO: "vim9script" 機能はまだ存在しません。Vim9 script の構文が完全に実装され
てから追加される予定です。


エクスポート ~
							*:export* *:exp*
アイテムのエクスポートは次のように書けます: >
	export const EXPORTED_CONST = 1234
	export var someValue = ...
	export final someValue = ...
	export const someValue = ...
	export def MyFunc() ...
	export class MyClass ...
	export interface MyClass ...

これが示唆するように、定数、変数、`:def` 関数およびクラスだけがエクスポートで
きます。{not implemented yet: class, interface}

							*E1042*
`:export` は Vim9 script のスクリプトレベルでしか使用できません。


インポート ~
						*:import* *:imp* *E1094*
エクスポートされたアイテムを別の Vim9 script で個別にインポートできます: >
	import EXPORTED_CONST from "thatscript.vim"
	import MyClass from "myclass.vim"

複数のアイテムを同時にインポートするには: >
	import {someValue, MyClass} from "thatscript.vim"

名前が気に入らない場合は別の名前を指定できます: >
	import MyClass as ThatClass from "myclass.vim"
	import {someValue, MyClass as ThatClass} from "myclass.vim"

エクスポートされたすべてのアイテムを特定の識別子のもとでインポートするには: >
	import * as That from 'thatscript.vim'

{not implemented yet: using "This as That"}

これにより "That.EXPORTED_CONST" や "That.someValue" などが使用できるようにな
ります。名前 "That" は自由に選べますが、混乱を避けるために {訳注: インポートさ
れる側の} スクリプトファイルの名前を使うことを強くお勧めします。

`:import` は旧来の Vim script でも使用可能です。プリフィックス "s:" が与えられ
なくても、インポートされたアイテムはスクリプトローカルになります。

`:import` の後ろのスクリプト名には以下のものが指定できます:
- "." か ".." で始まる相対パス。これはスクリプトファイルの位置を基準としてファ
  イルを検索します。大きなプラグインをいくつかのファイルに分割するのに便利で
  す。
- Unix では "/"、MS-Windows では "D:/" で始まる絶対パス。これはめったに使われ
  ません。
- 相対パスでも絶対パスでもないパス。これは 'runtimepath' のエントリの "import"
  サブディレクトリの中から検索されます。誤ったファイルを読み込まないために名前
  は通常、長くて一意なものになります。

一度 vim9 script ファイルがインポートされると、その結果はキャッシュされ、次回
同じスクリプトがインポートされるときに使われます。再び読み込まれることはありま
せん。
							*:import-cycle*
`import` コマンドは見つかったときに実行されます。対象のスクリプトが (直接また
は間接的に) 現在のスクリプトをインポートする場合、`import` の後ろで定義されて
いるアイテムはまだ処理されていません。そのためインポートが循環する可能性があり
ますが、未定義のアイテムとして終了することもあります。


オートロードスクリプトでのインポート ~

起動速度を最適化するためには、スクリプトの読み込みを実際に必要になるまで遅延す
る必要があります。おすすめの方法は次のとおりです:

1. プラグインスクリプトではオートロードスクリプトを参照するユーザー定義コマン
   ド、関数、マップなどを定義します。 >
	command -nargs=1 SearchForStuff searchfor#Stuff(<f-args>)

<   これを .../plugin/anyname.vim に書きます。"anyname.vim" は自由に選べます
   {訳注: 拡張子は .vim でなければなりません}。

2. オートロードスクリプトで実際の作業を行います。他のファイルからアイテムをイ
   ンポートすることで機能を適切なピースに分割できます。 >
	vim9script
	import FilterFunc from "../import/someother.vim"
	def searchfor#Stuff(arg: string)
	  var filtered = FilterFunc(arg)
	  ...
<   これを .../autoload/searchfor.vim に書きます。ファイル名の "searchfor" は
   関数名のプリフィックスと一致していなければなりません。さもないと Vim がファ
   イルを見つられなくなります。

3. プラグイン間で共有されうる機能が書かれたスクリプトには、エクスポートされた
   アイテムとプライベートなアイテムが含まれています。 >
	vim9script
	var localVar = 'local'
	export def FilterFunc(arg: string): string
	   ...
<   これを .../import/someother.vim に書きます。

`:def` 関数のコンパイル中にオートロードスクリプト内の関数が見つかった場合、
`:def` 関数が呼び出されるまでオートロードスクリプトはロードされません。


旧来の Vim script でのインポート ~

旧来の Vim script で `import` 文を使用した場合、"s:" が指定されていなくてもイ
ンポートされるアイテムにはスクリプトローカルな名前空間 "s:" が使用されます。


==============================================================================

6. 将来的な変更: クラス					*vim9-classes*

"クラス" については何度か言及しましたが、まだ実装されていません。Vim9 script
の大部分はこの機能がなくても作成できますし、クラスを実装するのは大変な作業にな
りそうなので将来に残しています。とりあえずクラスを後から追加できるようにだけし
ておきます。

考えていること:
- `class` / `endclass`、すべてのクラスを一つのファイルに
- クラス名は常に CamelCase (組み込み型との名前の衝突を防ぐため)
- "constructor" という名の単独のコンストラクタ
- `class ThisClass extends BaseClass` による単独の継承
- `abstract class` (実装が不完全なクラス)
- `interface` / `endinterface` (実装を持たない abstract class)
- `class SomeClass implements SomeInterface`
- クラスに対するジェネリクス: `class <Tkey, Tentry>`
- 関数に対するジェネリクス: `def <Tkey> GetLast(key: Tkey)`

繰り返しになりますが、多くは TypeScript 由来です。構文は若干異なりますが。

追加するとよさそうなもの:
- クラスをインターフェイスとして使う (Dart のように)
- インポートを使用してメソッドでクラスを拡張する (Dart のように)
- ミックスイン
- テスト用: モック機構

予定している重要なクラスの一つに "Promise" があります。Vim はシングルスレッド
なので、非同期な操作を接続することはプラグインがユーザーをブロックすることなく
作業を行えるようにするための自然な方法です。これはコールバックを呼び出したり、
タイムアウトやエラーを処理したりするための統一的な方法を提供します。

いくつかの例: >

	abstract class Person 
	    static const prefix = 'xxx'
	    var name: string
	    
	    def constructor(name: string)
		this.name = name;
	    enddef

	    def display(): void
		echo name
	    enddef

	    abstract def find(string): Person
	endclass

==============================================================================

9. 言語設計の背景					*vim9-rationale*

:def コマンド ~

プラグインの作者はより高速な Vim script を求めてきました。調査の結果、既存の関
数呼び出しのセマンティクスを維持したままでは高速化はほぼ不可能であることが分
かっています。関数の呼び出し、ローカル関数スコープの設定、行の実行にともなう
オーバーヘッドがあるからです。エラーメッセージや例外など、処理しなければならな
い細かい要素がたくさんあります。a: や l: スコープ用の辞書、a:000 リストなど様々
なものを作る必要があり、避けられないほど多くのオーバーヘッドが発生します。

そのため、新しいスタイルの関数を定義する `:def` メソッドを追加する必要がありま
した。これにより異なるセマンティクスを持つ関数を定義できます。ほとんどのものは
以前と同様に動作しますが、そうでない部分もあるでしょう。関数を定義する新しい方
法は、旧来のスタイルのコードと Vim9 スタイルのコードを分離するための最良の方法
だと考えられました。

関数定義に "def" を使うのは Python 由来です。"function" を使う言語もあります
が、これでは旧来の Vim script と衝突してしまいます。


型チェック ~

Vim コマンドの行を命令にコンパイルするとき、できるだけ多くの要素がコンパイル時
に処理されるべきです。実行時に後回しすると実行が遅くなるうえ、間違いが見つかる
のも後になります。例えば "+" 文字を見つけてこれを汎用的な加算命令にコンパイル
した場合、この命令は実行時に引数の型を調べて実行する加算の種類を決定しなければ
なりません。また、型が辞書の場合にはエラーを発生させなければなりません。型が数
値であることが分かっている場合は "数値の加算" 命令が使えます。これはより高速で
す。エラーをコンパイル時に検出できるほか、2 つの数値の加算が失敗することはない
ため実行時のエラー処理も省略できます。

複合型に <type> を用いる型の構文は Java と似ています。これは分かりやすいし広く
使われています。型の名前は、以前 Vim で使われていたものに "void" や "bool" な
どを追加したものです。


乱雑さや奇妙さを取り除く ~

`:def` 関数は旧来の関数と異なる構文を持つと決めたので、一般的なプログラミング
言語を知っているユーザーにとってより親しみやすいコードにするための改良を自由に
追加できるようなりました。言い換えれば: Vim 特有の奇妙なものを取り除けるように
なったということです。

また、古き良き Vi コマンドとの互換性のために存在していた乱雑さも取り除けるよう
になりました。

例:
- 関数呼び出しのための `:call` と、データ操作のための `:eval` を削除します。
- 行継続のためのバックスラッシュを削除し、式の終わりを自動的に認識します。

しかし、これにはいくつかの変更が必要でした:
- コメントは " ではなく # で始めます。文字列との混同を避けるためです。これは何
  にせよ良い変更でしょう。いくつかのポピュラーな言語で知られているからです。
- Ex コマンドの範囲指定にはコロンを前置する必要があります。式との混同を避ける
  ためです (シングルクォートが文字列やマークになったり、"/" が除算演算子や検索
  コマンドになったりします)。

目標は違いを限定することです。古い構文を誤って使用した場合、エラーメッセージが
表示される可能性が非常に高いと考えておくとよいでしょう。


ポピュラーな言語由来の構文とセマンティクス ~

スクリプトの作者から、Vim script の構文が慣れ親しんだ言語と予想外に異なるとい
う不満の声が上がっています。この不満を軽減するため、ポピュラーな言語を手本とし
て使用しています。同時に、旧来の Vim script のよく知られた部分を放棄したくはあ
りません。

多くのものは TypeScript を踏襲しています。これは最近人気が出てきた言語で Vim
script との類似点を持っています。また、静的型付け (変数は常に既知の値の型を持
つ) と動的型付け (変数は異なる型を持つことができ、実行時に決定される) が混在し
ています。旧来の Vim script は動的型付けであり、既存の機能 (特に組み込み関数)
の多くがそれに依存していますが、静的型付けははるかに高速な実行を可能にするの
で、Vim9 script ではこの混在が必要になりました。

TypeScript の構文やセマンティクスと完全に一致させるつもりはありません。ただ
Vim で使える部分、Vim ユーザーが喜んでくれそうな部分を採用したいだけです。
TypeScript は複雑な言語であり、独自の歴史、メリット、デメリットを持っています。
デメリットを知るには、この本を読んでみてください: "JavaScript. The Good
Parts"。または "TypeScript: the good parts" という記事を探して "Things to
avoid" というセクションを読んでみてください。

他の言語 (Java や Python など) に慣れている人でも TypeScript の中に苦手なこと
や理解できないことがあると思います。私たちはそのようなものを避けるつもりです。

避けている TypeScript の具体的な項目:
- "+" をオーバーロードして加算と文字列連結の両方に使用すること。これは旧来の
  Vim script に反しており、しばしば間違いを引き起こします。そのため文字列連結
  には引き続き ".." を使用します。これは Lua と同じ方法です。またこれにより、
  より多くの値を文字列に変換できます。
- TypeScript では "99 || 'yes'" のような式を条件に使用できますが、その値を
  boolean に代入することはできません。これは一貫性がなく厄介です。Vim では &&
  や || を使った式が認識され、その結果を真偽値として使用できます。TODO: 再検討
  する
- TypeScript は空文字列を Falsy とみなしますが、空のリストや辞書は Truthy とみ
  なします。これは一貫性がありません。Vim では空のリストや辞書も Falsy となり
  ます。
- TypeScript には様々な "Readonly" 型がありますが、その有用性は限られています。
  というのも型キャストによって不変性を破棄できるからです。Vim は値をロックする
  のでより柔軟ですが、実行時にしかチェックされません。


宣言 ~

旧来の Vim script ではすべての代入に `:let` を使いますが、Vim9 では宣言を使い
ます。これは違うものなので、違うコマンドを使うのがよいでしょう: `:var`。これは
多くの言語で使われています。セマンティクスは少し違うかもしれませんが、宣言であ
ると簡単に認識できます。

定数に `:const` を使うのは一般的ですが、そのセマンティクスは様々です。変数だけ
を不変にする言語もあれば、値も不変にする言語もあります。Java では "final" が変
数だけを不変にすることがよく知られているので、それを使うことにしました。また
`:const` を使って両方を不変にできるようにしました。これは旧来の Vim script で
も使われていたものであり意味はほとんど同じです。

最終的には Dart によく似たものになりました: >
	:var name	# 変数と値がともに可変
	:final name	# 変数は不変で値は可変
	:const name	# 変数と値がともに不変

旧来のスクリプトと Vim9 script が混在し、グローバル変数が共有されることになる
ので、オプショナルな型チェックが求められます。また型推論により、多くの場合に型
を指定する必要がなくなります。TypeScript の構文は宣言に型を追加するのに最適で
す: >
	var name: string	  # 文字列型が指定されています
	...
	name = 'John'
	const greeting = 'hello'  # 文字列型であると推論されます

宣言に型を含める方法は次のとおりです: >
	var mylist: list<string>
	final mylist: list<string> = ['foo']
	def Func(arg1: number, arg2: string): bool

これには 2 つの代替案が検討されました:
1. 変数名の前に型を書きます。Dart と同様です: >
	var list<string> mylist
	final list<string> mylist = ['foo']
	def Func(number arg1, string arg2) bool
2. 変数名の後ろに型を書きますがコロンは使用しません。Go と同様です: >
	var mylist list<string>
	final mylist list<string> = ['foo']
	def Func(arg1 number, arg2 string) bool

1 つ目は C や Java に慣れている人にとっては、より馴染みがあるものです。2 つ目
は 1 つ目に比べてあまりメリットがないので 2 つ目はやめておきましょう。

私たちは型推論を使用しているので、値から推論できる場合は型を省略できます。その
ため `var` の後ろに型が続くのか名前が続くのかが分かりません。これでは Vim だけ
でなく人間にとっても構文解析が難しくなります。また型の名前になり得る変数名を使
用できなくなりますし、`var string string` を使うと大変混乱します。

選ばれた構文は、名前と型を分離するためにコロンを使用するというものです。余計な
句読点を追加することになりますが、実際には宣言の各部分を認識しやすくなります。


式 ~

式の評価は既に他の言語と近い方法で行われていました。しかし細部には予想外なもの
もあり、改善の余地があります。例えば boolean の条件は文字列を受け取ると、それ
を数値に変換してその数値が非ゼロかどうかを調べます。これは予想外のことで、しば
しば間違いを引き起こします。というのも数字で始まらないテキストはゼロに変換さ
れ、偽とみなされるからです。そのため条件に文字列を使用してもエラーにはならず偽
とみなされることが多くあります。これは紛らわしいですね。

Vim9 では間違いを避けるために型チェックがより厳しくなっています。`:if` コマン
ドや `||` 演算子などの条件が使用される場所では、boolean のような値だけが受け入
れられます:
	真: `true`, `v:true`, `1`, `0 < 9`
	偽: `false`, `v:false`, `0`, `0 > 9`
Note 数値の 0 は偽、数値の 1 は真とみなされることに注意してください。これは他
の多くの言語よりも寛容です。このようにしたのは多くの組み込み関数がこれらの値を
返すからです。

何らかの型の値を boolean として使用したい場合は `!!` 演算子を使用します:
	真: `!!'text'`, `!![99]`, `!!{'x': 1}`, `!!99`
	偽: `!!''`, `!![]`, `!!{}`

JavaScript などの言語には次のような便利な構文があります: >
	GetName() || 'unknown'
しかし、これは条件には boolean しか使えないというルールと矛盾します。そこで
"??" 演算子が追加されました: >
	GetName() ?? 'unknown'
これにより値をそのまま使い、結果を boolean にしないという意図を明示的に表現で
きます。これを falsy 演算子 |falsy-operator| と呼びます。


インポートとエクスポート ~

旧来の Vim script の問題点として、デフォルトではすべての関数と変数がグローバル
であることが挙げられます。これらをスクリプトローカルにすることはできますが、そ
うすると他のスクリプトで利用できなくなります。これは、選択したアイテムだけをエ
クスポートして残りをローカルに保つというパッケージのコンセプトに反します。

Vim9 script では JavaScript のインポートとエクスポートによく似たメカニズムがサ
ポートされています。これは既存の `:source` コマンドの変形です。期待通りに動作
することでしょう:
- デフォルトですべてをグローバルにする代わりに、エクスポートしない限りすべてを
  スクリプトローカルにします。
- スクリプトをインポートするときインポートされるシンボルが明示的にリストアップ
  されるので、機能追加の際に起こる名前の競合や失敗を回避できます。
- このメカニズムにより、長大なスクリプトにとても分かりやすい API を組み込むこ
  とができます: エクスポートされた関数とクラスのことです。
- 相対パスを使用することでパッケージ内でインポートする場合の読み込みが格段に速
  くなり、多くのディレクトリを検索する必要がなくなります。
- 一度インポートが行われると、結果がキャッシュされるため、再読み込みを回避でき
  ます。
- アイテムをスクリプトローカルにするために "s:" を使うという Vim 特有の文法と
  おさらばできます。

旧来の Vim script から Vim9 script を source した場合は、グローバルに定義され
たアイテムだけが使えるようになります。エクスポートされたアイテムは使えるように
はなりません。これには以下の代替案が検討されています:
- エクスポートされたすべてのアイテムをスクリプトローカルなアイテムとして利用で
  きるようにします。これでは定義するアイテムを制御できないので、すぐにトラブル
  が起こりそうです。
- エクスポートされたアイテムをグローバルにします。デメリットはグローバルな名前
  空間における名前の衝突を回避できないことです。
- Vim9 script を source することを完全に禁止して `:import` の使用を要求します。
  これではスクリプトをテスト用に使用したり、コマンドラインから source して試し
  たりすることが難しくなってしまいます。
Note `:import` は旧来の Vim script でも使えます。上記を参照してください。


関数の早期コンパイル ~

関数は呼び出されたとき、または `:defcompile` が使用されたときにコンパイルされ
ます。関数を早期にコンパイルして構文と型のエラーを早期に報告できるようにしてい
ないのはなぜでしょうか?

関数は出会ってすぐにはコンパイルできません。なぜなら後から定義される関数への前
方参照があるかもしれないからです。関数 A、B、C が定義されていて、A が B を、B
が C を、C が A を呼び出す場合を考えてみてください。関数を並べ替えて前方参照を
回避することはできません。

別の方法としては、まずファイルをスキャンしてアイテムとその型をすべて洗い出し、
前方参照を見つけられるようにしてからスクリプトを実行して関数をコンパイルすると
いうものが考えられます。しかしこれではスクリプトを 2 回解析しなければならず、
時間がかかります。また特定の機能がサポートされているかどうかのチェックなど、ス
クリプトレベルの条件の中には扱いづらいものがあります。この方法が動作するかどう
かの試みは行われましたが、きれいに動作させることは不可能であることが分かりまし
た。

スクリプトの最後にすべての関数をコンパイルすることもできるでしょう。欠点は、あ
る関数が一度も呼び出されなかった場合、そのコンパイルにかけた時間がオーバーヘッ
ドになってしまうことです。起動速度はとても重要なので、たいていの場合、後からコ
ンパイルして、構文エラーと型のエラーはそのときに報告されるという動作を受け入れ
ることにしたほうがよいでしょう。早期にエラーを発見する必要がある場合、たとえば
テストの場合には `:defcompile` コマンドが役に立つでしょう。


なぜ埋め込み型の言語を使わないのか? ~

Vim は Perl、Python、Lua、Tcl などのインターフェイスをサポートしています。しか
し、これらのインターフェイスは様々な理由により普及しませんでした。Vim9 が設計
されたとき、これらのインターフェイスの優先順位を下げて Vim script に集中するこ
とが決定されました。

しかし、プラグインの作者は他の言語のほうが親しみやすいと感じたり、既存のライブ
ラリを使いたいと思ったり、パフォーマンス上のメリットを感じたりするかもしれませ
ん。私たちはプラグインの作者が他の言語でコードを書き、ジョブやチャネルを使って
プラグインを外部ツールとして実行することを奨励しています。私たちは、これをどう
にかして簡単にできないかと考えています。

外部ツールの使用にはデメリットもあるでしょう。代替案としてツールを Vim script
に変換するという方法も考えれます。あまり翻訳することなく変換を実現し、同時に
コードを高速に保つためには、ツールの構築をサポートする必要があるでしょう。たい
ていの言語はクラスをサポートしているので Vim でクラスがサポートされていないの
は問題です。


クラス ~

Vim では辞書にメソッドを追加することで一種のオブジェクト指向プログラミングをす
ることができます。これは少し注意すればうまく動きますが、本当のクラスのようには
見えません。そのうえ辞書を使っているのでかなり遅いです。

Vim9 script のクラスがサポートするのは多くの言語のクラスの "最小限の共通機能"
です。これは最もポピュラーなプログラミング言語である Java とよく似た機能になり
ます。



 vim:tw=78:ts=8:noet:ft=help:norl:
